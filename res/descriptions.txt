**************************************************
This Website

I am not a web designer by trade or education, but I am delving into the field out of curiosity alone.  Web development and the vast frameworks, tools, and server-side and client-side applications that make the web work have fascinated me for years.  By chance I have been unable to experience it thus far in my career, but the desire remains.  As my first foray into the world of web development, this website has provided a means of learning HTML, CSS, JavaScript, jQuery, AJAX, and the Bootstrap framework.  It has been a self-taught labor of love and I look forward to making it even more robust - if only to have an excuse to learn more cool things.

The site is hosted on an Amazon virtual machine EC2 instance, Ubuntu Server 14.04.  The source is up on GitHub: bss08380\mysite.

**************************************************
MC-VSG Control

The pride of my professional career, MC-VSG Control is the command/control application required by the X-COM Multi-Channel Vector Signal Generator.  The MC-VSG is a four channel by 150+ MSa/S I/Q playback device capable of achieving up to 3.2 GB/S of RF playback.  The control UI allows the user to complete playbacks, sequence files, view file meta data, and configure numerous operational settings on the device.  Furthermore, the interface is capable of controlling up to five simulataneous MC-VSG devices.  This presents a series of technical problems as each must be regularly polled and manipulated via UDP due to the limited capabilities of the on-board Power-PC processor.  

To solve these hurdles, the application (C#.NET/WPF) utilizes complex multi-threading schemes for the polling and UI logic, layers of inheritance hierarchies to aid in the management of devices and device types, and advanced C#.NET features such as generics and reflection.  It also includes a build-in TCP/IP API for use with unit-testing and hardware stress-testing.  The project is primarily MVVM where applicable in order to isolate the interface (of which there are many different views for any given view model), the view models, and the models and UDP data layers.

The result of this complexity is an application which is an aesthetically pleasing powerhouse capable of tracking and displaying multitudes of complex state information to a user at any given time without the need for explicit interaction.

The product is currently in use by various DoD entities and DoD contractors.

**************************************************
X-COM Control

X-COM Control is the command/control application required by the X-COM IQC 5000 A/B series products.  The IQC is a two channel I/Q record/playback system capable of up to 1.6 GB/S of sustained playback or record operations into SSD RAIDs capable of storing up to 32 TB of data.  X-COM Control enables users to configure, execute, and monitor recordings and playbacks of various types, sort through file metadata and marker information, and manage the files.  Built-in PCIe driver capabilities allow recorded data to be downloaded at up to 1GB/S.

The project is primarily C#.NET/WPF with an underlying interoperability layer which interfaces with the unmanaged C/C++ driver calls and optimized, high-speed transfer code.  Communication with the IQC requires a deep stack of UDP-based state retrieval logic, in which hundreds of registers need to be read and analyzed in order to determine the machine's current state, which is passed to the view layer through the view model.

The product is currently in use by numerous DoD entities, DoD contractors, and civilian companies.

**************************************************
Emulation

Testing software that interfaces with hardware suffers from one major nemesis: lack of hardware.  This problem became so prevelent in development and test scenarios, that I took the time to begin creating various automation tools for use in testing the X-COM projects listed above.  

In the case of the IQC, the Tektronix and Agilent front-end providers of I/Q data were not always available.  Our hardware team created a board to generate the data, and I created a WPF application to interface with X-COM Control and provide a simulated TCP/IP link over which standard Tektronix RSA5000/6000 and Agilent X-Series SCPI automation commands could be sent - effectively tricking our SW into thinking it was talking with actual HW resources.  This allowed us to continue development and test operations without the need for large amounts of expensive, in-house equipment.

In the case of the MC-VSG, it was a similar lack of equipment.  Some of our customers utilized many devices (including one which used 22 simultaneously).  In order to test this environment and the effects it would have on connectionless UDP packets, I had to run MC-VSG Control in an environment where there were multiple devices.  Since HW was not available, I wrote an application in C for the Raspberri Pi B+ to simulate the UDP transaction and device control of an MC-VSG.  This allowed me to create a small cluster of R-Pis and mimic the customer's operating network environment.

The C source for the project is available here for download if you would like to see what went into it (.zip).